/*
There is a bug in the GNU Assembler (GAS) that causes
the wrong instruction to be produced when instructions
like fsubp and fsubrp are specified. See:

http://www.mindfruit.co.uk/2012/03/trouble-with-fsub.html

There is supposed to be a #define that you can set to get
the correct instructions, but it seems not to work. See:

https://gcc.gnu.org/ml/gcc-bugs/2003-04/msg01454.html

Unfortunately, it seems to have no effect.
*/

//#define SYSV386_COMPAT 0		// this is the #define

#include <stdio.h>

int main()
{
	double		x = 4;
	double		y = 3;
	double		diff1, diff2;

	asm(
		"		fldl		%[x]		\n"
		"		fldl		%[y]		\n"
		"		fsubp					\n"
		// actually generates an fsubrp
		//   code bytes should be: DE E9
		//   actual code bytes:    DE E1
		"		fstpl		%[diff1]	\n"

		"		fldl		%[x]		\n"
		"		fldl		%[y]		\n"
		"		fsubrp					\n"
		// actually generates an fsubp
		//   code bytes should be: DE E1
		//   actual code bytes:    DE E9
		"		fstpl		%[diff2]	\n"

		:	[diff1]	"=m"	(diff1),
			[diff2]	"=m"	(diff2)
		:	[x]		"m"		(x),
			[y]		"m"		(y)
	);

	/*
	code bytes and code generated by objdump -S ...

	dd 44 24 28      fldl   0x28(%esp)
	dd 44 24 20      fldl   0x20(%esp)
	de e1            fsubp  %st,%st(1)
	dd 5c 24 18      fstpl  0x18(%esp)
	dd 44 24 28      fldl   0x28(%esp)
	dd 44 24 20      fldl   0x20(%esp)
	de e9            fsubrp %st,%st(1)
	dd 5c 24 10      fstpl  0x10(%esp)
	*/

	printf("fsubp:  result is %+2.0f, should be +1\n", diff1);
	printf("fsubrp: result is %+2.0f, should be -1\n", diff2);

	return 0;
}
